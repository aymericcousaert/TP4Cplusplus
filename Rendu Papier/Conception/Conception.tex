\documentclass{article}



\usepackage[latin1]{inputenc}    
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}     
\usepackage{listings}
\usepackage[margin=2.5cm]{geometry}

\date{INSA Lyon}
\title{Analyse de logs apache - Document de Conception}
\author{Aymeric Cousaert et Mael Risbourg}

\begin{document}
\maketitle

\vspace{1cm}
\tableofcontents
\vspace{1cm}

\begin{section}{Spécifications de l'application}
Afin de réaliser notre projet, nous avons tout d'abord dû comprendre quel était le but du programme et quels différents cas d'execution pouvons nous rencontrer. Nous avons donc spécifié ces cas  que nous pouvons classé en trois catégories :

Premièrement, il y a les cas normaux, ceux pour lesquelles notre programme est censé fonctionner sans aucun problème et qui avec un bon manuel d'utilisation devrait arriver le plus fréquemment. Ici, nous considérons que la syntaxte des commandes est toujours correctement respectée. Il y a donc le cas où seul le nom du dossier texte (.log ou .txt) est donné et notre programme affiche les 10 sites les plus consultés. Il y a ensuite les cas où une option est rajoutée en paramètre. Notre programme affichera toujours le top 10 mais créera en plus le fichier .dot si l'option -g est indiqué; filtrera les sites n'étant pas des images si -e est indiqué; ou encore filtrera seulement les consultations de sites à une certaines heures si -t est indiqué avec l'heure voulu. Enfin, plusieurs options peuvent être indiqué en même temps dans tel cas notre programme sera capable de toutes les traiter correctement.

Ensuite, il y a les cas limites qui vont en réalité dépendre des données recu dans le fichier texte. Nous avons relevé 3 cas limites. Tout d'abord, si l'execution avec les options ne débouche sur aucun résultats, nous l'indiquons à l'utilisateur et il n'y a donc aucun top 10 possible a afficher. Egalement, si l'execution donne quelques resultats mais pas suffisament pour afficher les 10 sites les plus consultés, nous indiquerons à l'utilisateur le classement avec seulement les sites possibles et donc celui-ci aura une taille inférieur à 10. Par ailleurs nous devons aussi prendre en compte le cas des exeaquos. Ainsi, si deux sites ont le même nombre de vues, nous choisissons de leur donner deux classement différents mais comme notre classement affichera aussi le nombre de visites, l'utilisateur sera capable de voir que les deux sites sont exaequos et il n'y aura donc pas d'ambiguïté. De plus, si l'égalité concerne le 10ème et le 11ème site, notre programme affichera un seul de ces sites afin de garder un top 10 et ne pas afficher trop de sites si il y a de nombreux exaequo.l'égalité concerne le 10ème et le 11ème site, notre programme affichera un seul de ces sites afin de garder un top 10 et ne pas afficher trop de sites si il y a de nombreux exaequo.

Enfin, il nous reste encore la plus grosse catégories qui est celle des cas d'erreur. Nous devons donc être capable d'anticiper tous les cas d'erreur qu'il peut être possible de produire afin de la traiter et pouvoir envoyer un message en conséquent.
La première erreur notable que l'on peut trouver est celle où le nom du programme est malorthographié dans le terminal mais ici nous ne pouvons rien faire car le programme ne s'executera pas. Nous allons donc considérer dans les prochaines erreurs que le nom du programme est correctement ecrit pour au moins qu'il puisse se lancer et ensuite traiter la possible erreur.
Dans un premier temps il peut y avoir un problème sur le fichier texte fournis. celui-ci peut soit être mal orthographié et donc introuvable, soit de mauvaise extension et donc inutilisable soit tout simplement pas renseigné dans telle cas le programme ne peut pas continuer.
Ensuite il peut y avoir des erreur sur les options si celle saisie est inexistante, si il manque le tiret devant ou encore si deux options sont accollées sans espace dans tel cas le programme considérera cela comme une option inconnu.
Enfin, il peut y avoir des erreurs liées à certaines options en particulier comme -g si le fichier de destination n'a pas la bonne extension (.dot) ou si celui ci n'est pas renseigné. L'option -t peut aussi avoir des cas d'erreur si jamais l'heure qui la suit n'est pas un entier compris entre 0 et 23 ou si l'heure n'est pas indiqué.

Il y a donc de nombreuse spécifications à prendre en compte dès le début du projet. Nous avons aussi trouver certaines d'entres elles durant la partie codage. Pour cela, il est nécessaire de préparer un jeu de test couvrant l'intégralité de ces spécifications afin de nous assurer du bon fonctionnement du programme.
En réalité, il y a souvent des spécifications non prévues  pouvant troubler l'exectution du programme ou provoquant une erreur ne correspondant pas à la vrai erreur. C'est pour cela qu'il est nécessaire de prendre le temps de bien définir aux mieux les spécifications en amont.
\end{section}

\begin{section}{Architecture globale de l'application}
Nous avons utilisé 3 classes : Ligne, Classement, et Graphe. La classe Ligne possède tous les attributs d'une ligne d'un journal de logs. La classe Classement possède un seul attribut qui est un tableau des 10 cibles les plus demandées. La classe Graphe possède également un seul attribut qui est une map dont le premier élément est un document accessible et le second et le nom donné au noeud qui lui est associé dans le graphe.
\end{section}


\begin{section}{Structures de données commentées et justifiées}
Au vu de la quantité de données à traiter, il est essentiel d'avoir une structure de données la plus adéquate possible pour deux grandes raisons. D'un côté il est important que notre programme soit capable de s'executer rapidement malgré la masse de données . D'autre part, il faut que notre structure de données prenne le moins de place possible en mémoire afin d'éviter des bugs et d'assurer l'execution correcte de notre programme. Pour cela il faut éviter le plus possible la redondance d'information ainsi que le stockage d'informations inutiles.
Nous avons donc longuement réfléchi à comment structurer nos données avant de coder. Nous voulions tout d'abords partir sur des listes chainées dans un set mais nous avons rapidement compris que cela n'était pas optimum et peut être même irréalisable de la façon dont nous voulions le faire. Nous nous sommes finalement tourner vers des maps.
\end{section}
\end{document}
