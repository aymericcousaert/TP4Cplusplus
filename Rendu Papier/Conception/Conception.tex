\documentclass{article}



\usepackage[latin1]{inputenc}    
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}     
\usepackage{listings}
\usepackage[margin=2.5cm]{geometry}

\date{INSA Lyon}
\title{Analyse de logs apache - Document de Conception}
\author{Aymeric Cousaert et Mael Risbourg}

\begin{document}
\maketitle

\vspace{1cm}
\tableofcontents
\vspace{1cm}

\begin{section}{Spécifications de l'application}
Afin de réaliser notre projet, nous avons tout d'abord dû comprendre quel était le but du programme et quels différents cas d'execution pouvons nous rencontrer. Nous avons donc spécifié ces cas  que nous pouvons classé en trois catégories :

Premièrement, il y a les cas normaux, ceux pour lesquelles notre programme est censé fonctionner sans aucun problème et qui avec un bon manuel d'utilisation devrait arriver le plus fréquemment. Ici, nous considérons que la syntaxte des commandes est toujours correctement respectée. Il y a donc le cas où seul le nom du dossier texte (.log ou .txt) est donné et notre programme affiche les 10 sites les plus consultés. Il y a ensuite les cas où une option est rajoutée en paramètre. Notre programme affichera toujours le top 10 mais créera en plus le fichier .dot si l'option -g est indiqué; filtrera les sites n'étant pas des images si -e est indiqué; ou encore filtrera seulement les consultations de sites à une certaines heures si -t est indiqué avec l'heure voulu. Enfin, plusieurs options peuvent être indiqué en même temps dans tel cas notre programme sera capable de toutes les traiter correctement.

Ensuite, il y a les cas limites qui vont en réalité dépendre des données recu dans le fichier texte. Nous avons relevé 3 cas limites. Tout d'abord, si l'execution avec les options ne débouche sur aucun résultats, nous l'indiquons à l'utilisateur et il n'y a donc aucun top 10 possible a afficher. Egalement, si l'execution donne quelques resultats mais pas suffisament pour afficher les 10 sites les plus consultés, nous indiquerons à l'utilisateur le classement avec seulement les sites possibles et donc celui-ci aura une taille inférieur à 10. Par ailleurs nous devons aussi prendre en compte le cas des exeaquos. Ainsi, si deux sites ont le même nombre de vues, nous choisissons de leur donner deux classement différents mais comme notre classement affichera aussi le nombre de visites, l'utilisateur sera capable de voir que les deux sites sont exaequos et il n'y aura donc pas d'ambiguïté. De plus, si l'égalité concerne le 10ème et le 11ème site, notre programme affichera un seul de ces sites afin de garder un top 10 et ne pas afficher trop de sites si il y a de nombreux exaequo.l'égalité concerne le 10ème et le 11ème site, notre programme affichera un seul de ces sites afin de garder un top 10 et ne pas afficher trop de sites si il y a de nombreux exaequo.

Enfin, il nous reste encore la plus grosse catégories qui est celle des cas d'erreur. Nous devons donc être capable d'anticiper tous les cas d'erreur qu'il peut être possible de produire afin de la traiter et pouvoir envoyer un message en conséquent.
La première erreur notable que l'on peut trouver est celle où le nom du programme est malorthographié dans le terminal mais ici nous ne pouvons rien faire car le programme ne s'executera pas. Nous allons donc considérer dans les prochaines erreurs que le nom du programme est correctement ecrit pour au moins qu'il puisse se lancer et ensuite traiter la possible erreur.
Dans un premier temps il peut y avoir un problème sur le fichier texte fournis. celui-ci peut soit être mal orthographié et donc introuvable, soit de mauvaise extension et donc inutilisable soit tout simplement pas renseigné dans telle cas le programme ne peut pas continuer.
Ensuite il peut y avoir des erreur sur les options si celle saisie est inexistante, si il manque le tiret devant ou encore si deux options sont accollées sans espace dans tel cas le programme considérera cela comme une option inconnu.
Enfin, il peut y avoir des erreurs liées à certaines options en particulier comme -g si le fichier de destination n'a pas la bonne extension (.dot) ou si celui ci n'est pas renseigné. L'option -t peut aussi avoir des cas d'erreur si jamais l'heure qui la suit n'est pas un entier compris entre 0 et 23 ou si l'heure n'est pas indiqué.

Il y a donc de nombreuse spécifications à prendre en compte dès le début du projet. Nous avons aussi trouver certaines d'entres elles durant la partie codage. Pour cela, il est nécessaire de préparer un jeu de test couvrant l'intégralité de ces spécifications afin de nous assurer du bon fonctionnement du programme.
En réalité, il y a souvent des spécifications non prévues  pouvant troubler l'exectution du programme ou provoquant une erreur ne correspondant pas à la vrai erreur. C'est pour cela qu'il est nécessaire de prendre le temps de bien définir aux mieux les spécifications en amont.
\end{section}

\begin{section}{Architecture globale de l'application}
Nous avons utilisé 3 classes : Ligne, Classement, et Graphe. La classe Ligne possède tous les attributs d'une ligne d'un journal de logs. La classe Classement possède un seul attribut qui est un tableau des 10 cibles les plus demandées. La classe Graphe possède également un seul attribut qui est une map dont le premier élément est un document accessible et le second et le nom donné au noeud qui lui est associé dans le graphe.
\end{section}


\begin{section}{Structures de données commentées et justifiées}
Au vu de la quantité de données à traiter, il est essentiel d'avoir une structure de données la plus adéquate possible pour deux grandes raisons. D'un côté il est important que notre programme soit capable de s'executer rapidement malgré la masse de données . D'autre part, il faut que notre structure de données prenne le moins de place possible en mémoire afin d'éviter des bugs et d'assurer l'execution correcte de notre programme. Pour cela il faut éviter le plus possible la redondance d'information ainsi que le stockage d'informations inutiles.
Nous avons donc longuement réfléchi à comment structurer nos données avant de coder. Nous voulions tout d'abords partir sur des listes chainées dans un set mais nous avons rapidement compris que cela n'était pas optimum et peut être même irréalisable de la façon dont nous voulions le faire. Nous nous sommes finalement tourner vers des maps.
En effet, nous avons en amont une classe Ligne qui comme expliqué précédemment nous permet de récupérer toutes les informations d'une ligne dans ses attributs. Nous devions donc récupérer les informations qui nous étaient nécessaire dans une structure de données adéquate.
Dans notre programme les informations les plus importantes sont les sites cibles et referer car nous cherchons dans un premier temps les nombre d'appel à un site cible mais aussi avec l'option -g le nombre d'appel d'un cite cible depuis un site referer particulier. Il nous semblait donc interressant de faire un premier map avec en clé le nom du site cible car celui ci est unique. Effectivement si l'on trouve dans notre fichier texte 2 sites cibles identiques c'est que l'on parle du même et donc il faut prendre cela en compte au même endroit de notre map. C'est pour cela que nous avons liés à chaque clés un types informations que nous avons nous même défini. 
Tout d'abord, on y retrouve le nombre d'itérations où la cible apparait dans le fichier. Cette valeur nous est indispensable pour pouvoir ensuite faire notre classement des 10 sites les plus visités. Nous avons choisis le type int car il est suffisant pour le jeu de données fournis mais si nécessaire il peut toujours être envisagé de l'étendre.
De plus, notre structures informations est aussi composé d'une map plutôt similaire à celle préceddemment décrite puis qu'elle prend en clé le nom des sites referers et en valeur le nombre d'apparition. Cela est indispensable pour executer notre programme avec l'option -g car il nous faut connaitre le nombre de fois où un referer particulier appel une cible particulière.
C'est donc pour cela que nous avons choisis de faire cette map referer au sein de la map cible car il nous est inutile de savoir combien de fois un referer a été trouvé dans le texte en général mais nous voulons savoir combien de fois il apparait pour une cible précise.
Avec cela, nous sommes donc capable de gérer notre classement des sites les plus visités de façon rapide car il n'y a pas de calcul à faire, nous avons juste à parcourir toutes les cibles de notre map et à prendre celle ayant la plus grande valeur dans la variable "iterations". Nous pouvons aussi générer notre fichier .dot de manière direct sans calcul supplémentaire en parcourant pour chaque cible tous les referers associés et y récuperer le nombre d'asociation entre les deux.

\end{section}
\end{document}
